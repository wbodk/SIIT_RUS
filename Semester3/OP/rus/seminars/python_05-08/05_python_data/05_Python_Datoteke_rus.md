# Текстовые файлы

## Текстовые файлы

- Текстовые файлы служат для постоянного (постоянного) хранения данных в текстовом формате на носителе массовой памяти
- Текст в файле должен соответствовать какому-то кодовому стандарту (чаще всего ASCII или UTF-8)


## Открытие файла

- Функция `open()` возвращает файловый объект, который представляет абстракцию Python над файлом
- Обычно используется с двумя аргументами `open(filename, mode)`
- Например: `f = open('workfile', 'w')`


## Режимы открытия файла

Параметр mode представляет режим, в котором файл открывается

- `'r'` - открывает файл в режиме для чтения
- `'w'` - открывает файл в режиме для записи с тем что предыдущий содержимое файла (если оно было) уничтожается
- `'a'` - открывает файл в режиме добавления в конец содержимого
- `'r+'` режим позволяет и чтение, и запись - параметр mode по умолчанию `'r'`


## Чтение из файла

- Метод `read(size)` объекта файла читает size символов из файла и возвращает считанное значение
как строку
- Если size не указан, то `read()` читает весь содержимое файла
- Текстовый файл можно читать построчно с помощью метода `readline()` объекта файла

- Через строки файла можно итерировать так:
    ```python
    for line in f:
            print(line, end='') 
    ```
- Список всех строк можно получить с помощью `list(f)` или
    `f.readlines()`
- Рекомендуется использовать `with` конструкцию при работе с файлами:  
    ```python
    with open('workfile') as f:
        read_data = f.read()
    ```
- `with` гарантирует корректное закрытие файла даже в случае возникновения исключения


## Запись в файл

- Метод _`write(content)`_ объекта файла записывает переданный контент в файл, который был открыт в режиме записи

- `f.write('This is a test\n')`
- `write()` возвращает количество записанных символов как возвращаемое значение
- Объекты, не являющиеся строкой, сначала необходимо преобразовать в строку с помощью `str()` и затем записать в текстовый файл

# Бинарные ФАЙЛЫ

## Открытие, чтение и запись

Бинарные файлы открываются так же, как и текстовые, просто не обходимо в `mode` параметр добавить символ `‘b’`

- `f = open('workfile', 'rb+')`
- Для чтения используется метод read(size), который возвращает объект класса `bytes`
- Для записи используется метод write(content), где content параметр имеет тип bytes


## Встроенный класс bytes

Позволяет создавать объекты, содержащие неизменяемый массив байтов 

- `x = b”some content”`
- Поддерживает только ASCII значения как литералы, все остальные символы задаются с использованием escape последовательностей
- Для изменяемого массива байтов используется класс `bytearray`
- Классы `bytes` и `bytearray` поддерживают большинство стандартных методов строки: `replace`, `removeprefix`, `join` ...


## Навигация по бинарному файлу

- В отличие от текстовых файлов, которые чаще всего читаются и записываются последовательно (от начала до конца), при работе с бинарными файлами часто необходимо перемещаться на определенную позицию внутри файла
- Метод `tell()` объекта файла возвращает текущую позицию внутреннего индикатора внутри файла, которая представляет собой количество байтов до начала файла
- Метод `seek(offset, whence)` позволяет изменить позицию в файле
  - `offset` это количество байтов относительно опорной точки
- `whence` опорная точка, и может быть:
    - 0 - начало файла (значение по умолчанию)
    - 1 - текущая позиция
    - 2 - конец файла
- Примеры:
  - `f.seek(5)` # Перейти к 6-му байту в файле
  - `f.seek(-3, 2)` # Перейти к 3-му байту до конца


## Сериализация и десериализация объектов

- Модуль `pickle` реализует бинарный протокол
для сериализации и десериализации объектов
Python
- `pickle` поддерживает сериализацию и
десериализацию
  - логических и числовых типов
  - строк, кортежей
  - списков, множеств, словарей, содержащих элементы, которые являются каким-то из перечисленных выше типов
- Функция `pickle.dump(obj, file)` позволяет сериализовать объект в бинарный файл
- Для обратной операции используется функция `pickle.load(file)`

# Задачи

## Текстовые файлы

### Пример 1

Создать текстовый файл и заполнить его 5 строками произвольного текста и прочитать созданный файл:
- символ за символом
- строка за строкой
- сразу

Содержимое файла переписать в новый файл в обратном порядке:
- строк
- символов
 
### Задача 1

Загрузить произвольный текстовый файл и подсчитать:
  - символы
  - буквы
  - цифры
  - слова
  - предложения

### Задача 2

- З из входного файла загрузить данные об автомобилях в массив
- Для введенного объема двигателя найти самый новый автомобиль с объемом не более заданного
- Пример файла:
    ```plaintext
    AlfaRomeo 1200 2005
    BMW 2200 2011
    AUDI 1900 2010
    Zastava 1600 1998
    Ferrari 2500 2013
    ```

### Задача 3

- Для заданного символа c и натурального числа d сформировать текстовый файл со знаком «квадрат» из символов c, шириной и высотой 2d+1 символа
- Пример: 
    ```python
    c='#', d=3
    res = 
    '''
    #
    ###
    #####
    #######
    #####
    ###
    #
    '''
    ```

## Бинарные файлы

### Пример 2

- Значение целочисленной переменной записать в
бинарный файл
- Прочитать созданный файл
- Удвоенное прочитанное значение записать в
новый файл


### Пример 3

- Значение строковой переменной записать в бинарный
файл
- Прочитать созданный файл
- К прочитанному значению добавить несколько не-
ASCII (UTF-8) символов и записать строку в новый
файл
- Прочитать UTF- 8 файл и прочитать только
последние 6 байт


### Пример 4

- Словарный объект сериализовать в файл
- Прочитать созданный файл
- Изменить десериализованный словарь
- Вывести измененный словарь в новый файл


### Задача 4

- Прочитайте CSV-файл как массив кортежей (tuple).
- Сериализуйте прочитанный массив в двоичный файл.
- Пример входного файла:
    ```csv
    Grad, Uslovi, MinTemp, MaxTemp
    Beograd, Oblačno, 6,12.5
    Novi Sad, Oblačno, 5, 11
    Subotica, Sunčano, 6, 12
    Zrenjanin, Kišovito, 4, 11
    Nevesinje, Sunčano, 6, 13
    ```

### Задача 5

- У вас есть двоичное изображение BMP.
- На втором байте находится размер файла (4 байта).
- На десятом байте находится размер заголовка файла (4 байта).
- Скопируйте байты из заголовка в новый файл.
- Загрузите остальные байты в переменную типа int (по одному).
- Выведите комплементарные значения (255 - x) в новый файл.