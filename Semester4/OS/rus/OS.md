# Оперативные системы

> Лекции Goran Savić <savicg@uns.ac.rs> NTP 337

> Практики Sanja Špica <sanjaspica@uns.ac.rs> NTP 337

Лекции:
 - [Лекция 1](#лекция-1)

Содержание курса:

1. Конкурентное программирование
    - Понятие потока
    - Взаимное исключение
    - Условная синхронизация
2. Операционные системы
    - Роль операционной системы
    - Процессы
    - Управление памятью
    - Планирование процессора
    - Управление подсистемой пользовательского интерфейса (UI)
    - Управление файлами

Книги:
- Operativni sistemi, principi unutrašnje organizacije i dizajna, 7. izdanje, William Stallings, CET, Beograd, 2013.
- Operating system concepts 9th edition, A.
Silbershatz, P.B. Galvin, G. Gagne, Wiley, 2013.

Ютуб:
- www.youtube.com/ftnenastava (Для первого колка)
- www.youtube.com/timek12 (Материал 1й половины)

## Лекция 1

Состояния процесса:

![1](imgs/lecture1/1.png)

Исполнение
    - процесс, инструкции которого процессор в данный момент выполняет
Готов
    - процесс, который готов к выполнению, но в данный момент процессор не выполняет его инструкции
Заблокирован (В ожидании)
    - процесс, который не может выполняться до наступления определенного события например, завершение операции ввода-вывода
Новый
    - процесс, который только что создан, но операционная система еще не приняла его в очередь готовых процессов
Выход
    - процесс, который операционная система убрала из очереди готовых процессов, потому что он завершил свою работу


Способность операционной системы поддерживать несколько конкурирующих путей выполнения одного процесса
Поток (нить) - это один путь выполнения в рамках процесса

Нити в C++11:
- Представленный объектом класса thread из заголовочного файла <thread>
- Создание объекта создает новый поток, который становится готовым
- Параметр конструктора класса thread - это функция, которую выполняет поток
(Эта функция называется телом потока)
- Входной точкой программы по-прежнему является функция main
- Завершение происходит, когда завершается функция main

Отношение создателя к созданному потоку

Метод join() класса thread
- Создатель ждет, пока созданный поток завершит выполнение
- Таким образом, два потока выполнения объединяются
-  Метод является блокирующим
(Создатель будет заблокирован, пока созданный поток не завершит выполнение)
Метод detach() класса thread
-  Отделяет создателя от созданного потока
-  Тогда создателю разрешено завершить выполнение независимо от выполнения созданного потока

Передача параметров в поток
-  Параметры тела потока передаются как параметры конструктора класса thread после имени функции
-  Возвращаемое значение функции игнорируется
-  Необходимо передавать объекты по ссылке в функцию
-  Необходимо явно передавать ссылку с использованием ref(object)

Пример улучшения производительности с использованием многозадачной обработки

-  Программа отправляет два запроса удаленному серверу для вычисления результата
-  Вариант с одним потоком

![1](imgs/lecture1/2.jpg)

-  Вариант с двумя потоками
-  Блокировка одного потока не блокирует другой поток

![1](imgs/lecture1/3.jpg)

#### Польза от многопоточной обработки

#### Фоновая задача
-  Длительные или блокирующие фоновые операции могут выполняться в отдельном потоке, например, запись в журнальный файл
-  Взаимодействие с пользователем возможно даже в то время, когда другой поток еще не завершил операцию
#### Асинхронная обработка
-  Команда передает задачу другому потоку
-  Поток, который передал задачу, может продолжить выполнение других команд, пока предыдущая еще не завершилась
#### Скорость выполнения
-  Пока один поток процесса блокирован, другие могут продолжать выполнение
#### Деление ресурсов внутри приложения
-  Потоки одного процесса разделяют одну и ту же память
-  Более быстрое и простое взаимодействие между потоками по сравнению с процессами
#### Экономичность
-  Создание нового потока быстрее, чем отдельного процесса
-  Переключение между двумя потоками одного процесса быстрее, чем между двумя процессами
#### Использование многопроцессорной архитектуры
-  Возможность ускорения приложения, если потоки выполняются на разных процессорах
#### Модульная структура программы
-  Организация кода в несколько потоков разделяет логические части программы
-  Более простая реализация и обслуживание

![1](imgs/lecture1/4.gif)

1. Операционная система поддерживает только один процесс, содержащий один поток (MS DOS)

2. Операционная система поддерживает несколько процессов, каждый из которых содержит один поток (традиционный UNIX)

3. Среда содержит один процесс, в котором может существовать несколько потоков (Java VM)

4. Операционная система поддерживает несколько процессов, каждый из которых поддерживает несколько потоков (Windows, Linux, Solaris)

### Процесс в многозадачной обработке
- Единица выделения ресурсов
  - виртуальное адресное пространство, в котором находится образ процесса
- Единица защиты ресурсов
  - защищенный доступ
  - процессору
  - другим процессам (межпроцессное взаимодействие)
  - файлам
  - вводу/выводу (устройства, каналы)

### Нить в многозадачной обработке
Один процесс может содержать несколько потоков.
У каждого потока есть:
- Состояние выполнения (выполнение, готовность и т. д.).
- Контекст потока: сохраненное состояние регистров процессора во время ожидания выполнения.
- Стек выполнения потока.
- Доступ к памяти и ресурсам своего процесса, общий с другими потоками того же процесса.

### Модель процесса с многозадачностью
![1](imgs/lecture1/5.gif)
Каждый поток имеет свой управляющий блок и стек
Все потоки разделяют адресное пространство и имеют доступ к одним и тем же данным

### Планирование потоков
-  Если операционная система поддерживает потоки, планирование выполняется на уровне потоков.
-  Большая часть информации о состоянии выполнения сохраняется на уровне потоков.
-  Некоторые действия влияют на все потоки.
-  Тогда операционная система должна выполнять планирование на уровне процессов.
   - Например, прерывание процесса прерывает все его потоки.

### Состояния потока
- Как и у процесса
  - Выполнение
  - Готов
  - Заблокирован
- Действия, изменяющие состояние потока
  - Создание
  - Создается управляющий блок потока и стек, и поток переводится в состояние готовности.
- Блокирование
  - Когда поток должен ожидать события,
  -  содержимое регистров процессора сохраняется, и процессор переключается на другой поток из готового набора.
- Разблокирование
  - Когда происходит ожидаемое событие, на которое ожидался поток.
  - Завершение

### Синхронизация потоков

-  Все потоки одного процесса разделяют одно и то же адресное пространство
-  Необходимо синхронизировать доступ к этим общим ресурсам
-  Без синхронизации
   - может возникнуть некорректная работа программы
   - ресурсы могут оказаться в несогласованном состоянии

Типы потоков:

Потоки уровня пользователя
User Level Threads (ULT)

Потоки уровня ядра
Kernel Level Threads (KLT)


Потоки уровня пользователя (ULT)
- Вся работа по управлению потоками выполняется
приложением
- Ядро не осведомлено о существовании
потоков
- Потоки создаются в рамках приложения
с использованием библиотеки потоков
- Библиотека включает код для
  - создания и уничтожения потоков
  - передачи сообщений и данных между потоками
  - планирования потоков
  - сохранения и восстановления содержимого потоков
- Все действия выполняются в пользовательском
пространстве в пределах одного процесса

![1](imgs/lecture1/7.png)

Планирование потоков на уровне пользователя
- Ядро (Kernel) планирует процессы и назначает им состояние
- Потоки имеют свое собственное состояние, которое представляет собой "логическую" категорию и
не прямо связано с состоянием процесса
- Состояние потока обозначает статус потока внутри процесса
- Например, состояние потока "Исполнение"
  - означает, что поток активен в пределах процесса
  - не обязательно означает, что поток в данный момент выполняется на
процессоре
  - когда процессор начнет выполнять процесс, выполняется
поток в состоянии "Исполнение" внутри этого процесса

![1](imgs/lecture1/6.png)

Преимущества и недостатки ULT (User Level Threads)

Преимущества:
- Переключение потоков не требует перехода в режим ядра операционной системы.
- Приложение может реализовать собственный алгоритм планирования потоков.
- ULT могут выполняться на любой операционной системе.

Недостатки:
- При блокировке процесса все потоки этого процесса также блокируются.
- Невозможность использования многозадачности, так как все потоки принадлежат одному процессу и выполняются на одном процессоре.

Потоки уровня ядра (KLT)
- Приложение инициирует создание
потоков
- Вся управляющая работа с потоками
выполняется ядром
- Ядро поддерживает данные
  - для всего процесса
  - для каждого отдельного потока
- Ядро осуществляет планирование
на основе потоков

![1](imgs/lecture1/8.png)

Преимущества и недостатки KLT ("Kernel-Level Threads")

**Преимущества:**
- Ядро может одновременно планировать выполнение нескольких потоков одного процесса на нескольких процессорах.
- Если один поток в процессе заблокирован, ядро может планировать выполнение другого потока того же процесса.

**Недостатки:**
- Переключение между потоками одного процесса требует перехода в режим ядра.
- Поэтому коммутация KLT на порядок медленнее, чем коммутация ULT (User-Level Threads).

Комбинированные подходы
- Создание потоков и большая часть управления и планирования выполняются в пространстве пользователя.
- Множество пользовательских потоков (ULT) могут быть отображены на некоторое (меньшее или равное) количество ядерных потоков (KLT).

![1](imgs/lecture1/9.png)
