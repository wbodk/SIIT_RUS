```table-of-contents
title: # Содержание
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
# Открывание подходящих мест в коде для параллельной обработки
Различия между конкурентными и параллельными системами:
- **Конкурентные системы** - это несколько задач, которые начинаются, выполняются (не обязательно непрерывно) и завершаются так, что имеется перекрытие.
- **Параллельные системы** - это выполнение нескольких задач одновременно на одном аппаратном обеспечении, которое содержит несколько вычислительных ресурсов, таких как многоядерные процессоры, процессор + графическая карта и т.д.

Три основных вопроса, которые мы задаем:
1. Где внедрить параллелизм (какой сегмент кода занимает больше всего времени)?
2. Как внедрить параллелизм (какие техники, какие шаблоны, инструменты, фреймворки)?
3. Есть ли проблемы с синхронизацией?

Определение мест для параллелизации:
- С использованием инструментов, предназначенных для этого, таких как Intel Advisor (требуется полный пакет, включая компилятор Intel).
- "Пешком", изучая код и измеряя время выполнения.
- Лучшие кандидаты для параллелизации обычно являются циклы и рекурсивные функции, но все, что занимает много времени, должно быть рассмотрено.

Как внедрить параллелизм? Существует различные методы и фреймворки, каждый со своими преимуществами и недостатками:
- Потоки (предоставляют программисту больший контроль, но требуют большей ответственности и знаний архитектуры).
- Программные фреймворки, такие как OpenMP, Cilk++, Intel OneTBB (упрощают внедрение параллелизма, но имеют ограниченные возможности).
- Фреймворки для гетерогенных систем, такие как OpenCL (более сложные).

На этом курсе мы сосредоточимся на **Intel OneTBB** в большей части семестра, а небольшую часть уделяем **OpenCL**.
- Синхронизация - проблема, которая не существует в последовательных программах.
- Что происходит, если несколько потоков / задач имеют доступ к одной и той же переменной / структуре / классу?
- Как обеспечить согласованность?
- У нас достаточно ресурсов, чтобы каждый поток / задача работал(а) с собственной локальной копией?
Это некоторые из вопросов, на которые мы ответим в течение семестра...
# Пример N королев
Для заданной шахматной доски произвольного размера, сколько королев можно разместить так, чтобы они **не атаковали друг друга**? Для малых размеров проблему можно решить "насилием", то есть перебором всех возможных комбинаций и выбором правильных.

![](Semester4/PP/rus/seminars/seminar%2001/imgs/1.png)

Проблема является **экспоненциальной**, и с увеличением размеров она становится неразрешимой в разумное время. Поэтому используется алгоритм "backtracking", который работает по следующему принципу:
- Размещаем королеву на первое свободное поле.
- Размещаем новую королеву в следующей колонке на первое свободное поле.
- Если королевы атакуют друг друга, удаляем последнюю добавленную королеву и размещаем её на следующее поле.
- Если нет больше свободных полей, удаляем предыдущую королеву и перемещаем её на следующее свободное поле.
- Если мы успешно разместили королеву в последнюю колонку, нашли одно решение и его следует занести в запись.

Этот алгоритм существенно сокращает количество случаев, которые нужно обработать. Помимо этого алгоритма, мы можем воспользоваться тем, что доска симметрична, так что для определенных размеров мы можем использовать решения, которые являются "в зеркале" или повёрнутыми на 90 градусов.

Из анализа кода и измерения времени можно заключить, что большая часть времени тратится в цикле, в котором вызывается функция `setQueen()`. Внутри функции есть цикл, который проходит по всем строкам и столбцам.

Можем ли мы параллелизовать этот цикл? Являются ли итерации независимыми? Ответы на эти вопросы дадут нам понимание того, как мы можем выполнить параллелизацию.

# Способы параллелизации циклов
Независимые итерации:

| Loop control i = 0 |
| ------------------ |
| Func 1 i = 0       |
| Func2 i = 0        |
| Func1 i = 1        |
| Func2 i = 1        |
| ...                |
| Func1 i = N-1      |
| Func2 i = N-1      |

Зависимые итерации:

| Loop control i = 0 | Loop control i = 1 | ...<br> | Func 1 i = N-1     |
| ------------------ | ------------------ | ------- | ------------------ |
| Func 1 i = 0<br>   | Func 1 i = 1<br>   | ...     | Func 1 i = N-1     |
| Func 2 i = 0       | Func 2 i = 1       | ...     | Func 2 i = N-1<br> |
Если итерации независимы, мы прибегаем к одному из шаблонов параллелизации цикла (OpenMP и OneTBB имеют parallel for, Cilk+ имеет cilk_for). Очень простое решение, обычно достаточно эффективное.

Если итерации не являются независимыми, тогда мы используем какой-то вид разделения работы на задачи, которые затем связываем и синхронизируем между собой (задачи из K-той итерации должны завершиться перед тем, как задачи из (K+1)-й итерации начнут выполняться). Какова ситуация в случае задачи с N королевами?
# Критичные секции программы
Критическая секция программы представляет собой инструкцию или блок инструкций, которые должны выполняться **непрерывно**. Другими словами, если один поток / задача выполняет данный блок, другие потоки / задачи НЕ ДОЛЖНЫ одновременно выполнять этот блок.

Критические секции связаны с взаимозависимостью данных и возникают, когда несколько потоков / задач имеют доступ к одному ресурсу, при этом хотя бы один из них изменяет его (т.е. записывает что-то).

Критические секции представляют собой значительное ограничение, которое влияет на уровень параллелизма, достигаемый в программе, и, следовательно, на максимальное ускорение, достижимое путем параллелизации программы.

Как решить критические секции?
- **Закрытием** - самый простой метод, но он сильно замедляет программу; приемлемо, если критическая секция короткая (небольшой кусок кода) и если блокировка не будет происходить слишком часто.
- **Копированием** - каждый поток / задача получит свою копию критического ресурса, с которой будет работать, и в конце необходимо обеспечить механизм, который объединит все копии в единственное значение; требует потенциально много ресурсов и иногда просто невозможно.
- **Изменением** кода так, чтобы критическая секция была исключена - рефакторинг кода и изменение алгоритма так, чтобы не было критической секции.
# Intel OneTBB
TBB (Threading Building Blocks) - это C++ фреймворк, который скрывает от пользователя детали работы с потоками. Работает на более высоком уровне абстракции (мы думаем на уровне задач, которые нужно выполнить), используя библиотеки и шаблоны, которые у нас есть, а диспетчер задач сам создает потоки и распределяет задачи между ними.

В течение семестра мы подробно изучим некоторые из функциональностей, которые предлагает этот фреймворк.
# Параллельное решение N королев с использованием TBB
`spin_mutex` позволяет нам заблокировать переменную при записи в общую переменную.

Шаблон `parallel_for` для параллельного цикла `for` позволяет нам одновременно запустить большое количество задач, которые будут независимо друг от друга искать решение (начиная с разных начальных позиций).

Запустите оба примера и сравните время выполнения и результаты.
# Запуск упражнений
Для сборки и запуска программ мы будем использовать инструмент Waf и операционную систему Linux.
Шаги выполнения:
1. Перейдите в каталог, где находятся исходные файлы и скрипт waf.
2. Добавьте права на выполнение скрипту командой `chmod 777 waf`.
3. В терминале введите команду `./waf configure`.
4. Если предыдущий шаг выполнен успешно, введите команду `./waf build`.
5. Затем введите команду `./waf run --app=имя_приложения`.

Для студентов, которые хотят работать на своих ноутбуках под управлением Windows, лучше всего установить MS Visual Studio и с ним OneTBB, создать новую программу и просто добавить файлы из упражнения.

Те, кто настаивает на использовании Windows и не хочет устанавливать MS Visual Studio, могут использовать любую другую среду, но должны самостоятельно настроить пути к библиотекам TBB.